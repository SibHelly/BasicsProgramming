#include <stdlib.h>
#include <stdio.h>
#include <float.h>

int main()
{
    float f;
    double d;
    printf("sizeof(f)=%d\tsizeof(d)=%d\n\n", sizeof(f), sizeof(d));/*выводим на экран объем данных типов float и double в байтах*/
    d = f = FLT_MAX;/*присваиваем переменным d и f максимальное значение типа float*/
    printf("FLT_MAX : f=%g d=%g\n", f, d);
    d = f = FLT_MIN;/*присваиваем переменным d и f минимальное значение типа float */
    printf("FLT_MIN : f=%g d=%g\n", f, d);
    d = f = FLT_EPSILON;/*точность типа float*/
    printf("FLT_EPSILON : f=%g d=%g\n", f, d);
    f = 12345678;/*присвоим переменной f типа float c точность 7-8 знаков восьмиразрядное число*/
    printf("12345678 : f=%f\n", f);
    f = 123456789;/*присвоим переменной f типа float c точность 7-8 знаков девятиразрядное число,
    которое будет искажено, из-за недостаточной точности(цифру после 8 негде хранить поэтому программа
    подставляет хаотичное число).*/
    printf("123456789 : f=%f\n", f);
    f = 1234567890;/*присвоим переменной f типа float c точность 7-8 знаков десятиразрядное число,
    которое будет искажено, из-за недостаточной точности типа float(цифры после 8 негде хранить поэтому программа
    подставляет хаотичные).*/
    printf("1234567890 : f=%f\n", f);
    d = DBL_MAX;/*присвоим максимальное значение типа double*/
    printf("DBL_MAX : d=%g\n", d);
    d = DBL_MIN;/*присвоим минимальное значение типа double*/
    printf("DBL_MIN : d=%g\n", d);
    d = DBL_EPSILON;/*точность типа double до 16 знаков */
    printf("DBL_EPSILON : d=%g\n", d);
    d = 1e15 + 1;/*прибавленная 1 сохраняется, так как точность до 16 знаков */
    printf("1e15+1 : d=%lf\n", d);
    d = 1e16 + 1;/*прибавленная 1 теряется(ее негде хранить, так как тогда число становитьс
    17-ти значным, и 17 цифру программа теряет, и на ее метсо подставляет хаотичное число),
    так как точность до 16 знаков*/
    printf("1e16+1 : d=%lf\n", d);
    d = 10000 * 100000 + 1 - 4 * 250000000;/*получаем верный результат, так как результаты
    в промежуточных действиях состоят из меньшего количества цифр, чем точность */
    printf("1 : d=%lf\n", d);
    d = 1e20 * 1e20 + 1000 - 1e22 * 1e18;/*при вычислении результата данного выражения
    мы прибавляем к 40 значному числу 1000, которая, так как точность идет до 16 знаков,
    поэтому на промежуточном дейстиве 1000 была потеряна и в конечном резултате получился 0*/
    printf("1000 : d=%lf\n", d);
    d = 1e20 * 1e20 - 1e22 * 1e18 + 1000;/*при вычитании одинаковых 40 значных чисел программа получает
    промежуточный результат 0(ничего не теряет, так как они одинаковые и ничего к ним не прибавляется),
    поэтому при 0+1000, мы получаем 1000, */
    printf("1000 : d=%lf\n", d);
    f = d = 0.3;/*погрешность из-за точности в float до 7 знаков, в double до 16 знаков */
    printf("0.3 : f=%.8f  d=%.17f\n", f, d);
    f = 0;/*присваиваем переменной f =0*/
    while (f < 10)/*запускаем цикл, для просмотра за изменением числа f при +0.2 дотого момента пока оно не будет >=10*/
        f += 0.2;
    printf("10 : f=%f\n", f);
    return 0;
}
